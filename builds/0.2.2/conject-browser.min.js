/* conject 0.2.2 | (c) Fabio Mereu | MIT license | https://github.com/medenagan/conject | 2026-02-02T11:55+01:00 */
!function(f){"object"==typeof exports&&"undefined"!=typeof module?module.exports=f():"function"==typeof define&&define.amd?define([],f):("undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).conject=f()}(function(){return function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);throw(f=new Error("Cannot find module '"+i+"'")).code="MODULE_NOT_FOUND",f}c=n[i]={exports:{}},e[i][0].call(c.exports,function(r){return o(e[i][1][r]||r)},c,c.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}({1:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;exports.default=(dest,source)=>{for(var key in source){var descriptor=Object.getOwnPropertyDescriptor(source,key);Object.defineProperty(dest,key,descriptor)}return dest};module.exports=exports.default},{}],2:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;_interopRequireDefault(require("./evaluation"));var _condition=_interopRequireDefault(require("./condition")),_assign=_interopRequireDefault(require("./assign"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let _=new WeakMap,DEBUG_COUNTER=0,CHAINABLE_PROTOTYPE={toString:function(){return"C"+_.get(this).chain.map(link=>`.${link.method.name}(${link.params.map(String).join(", ")})`).join("")},get condition(){var chain=_.get(this).chain;return chain.length&&chain[chain.length-1].condition||FALSE},toPromise:function(initialValue){return this.condition.toPromise(initialValue)},run:function(initialValue,scope){initialValue=this.condition.test(initialValue,scope);return initialValue.on(),initialValue},debug:function(initialValue,scope){initialValue=this.condition.test(initialValue,scope);let handle="#"+ ++DEBUG_COUNTER;return console.log(`[1m[37m[46mTEST ${handle} runs[0m[1m[36m C${this.toString()}[0m`),initialValue.on(value=>{var valueColor="[1m"+(value?"[32m":"[33m");console.log(`TEST ${handle}: [${valueColor}${!!value}[0m]`+valueColor,value,"[0m")},reason=>{console.error(`[1m[37m[41mTEST ${handle} rejects the evaluation,`,reason,"[0m")}),initialValue.async?console.log(`[2m[4m[33mTEST ${handle} is running asynchronously[0m`):console.log(`[2m[36mTEST ${handle} has run synchronously[0m`),initialValue},get _chain(){return _.get(this).chain.map(link=>Object.assign({},link))}},_isChainable=what=>(what=_.get(what))&&"object"==typeof what&&Array.isArray(what.chain);class Chainable{constructor(source){function ChainableInstance(...params){return ChainableInstance.run(...params)}source=_isChainable(source)?_.get(source).chain.slice():[];return _.set(ChainableInstance,{chain:source}),(0,_assign.default)(ChainableInstance,CHAINABLE_PROTOTYPE)}}Chainable.isChainable=_isChainable;require=[{starter:!0,name:"if",compile:(root,...params)=>{if(1!==params.length)throw new Error(".if accepts only one Condition as parameter");if(root)throw new Error(".if can be used only as first method in the chain. Use .and, .or, ... instead");return fromAny(params[0])}},...[{starter:!0,name:"and",constructor:_condition.default.SequentialAnd},{starter:!0,name:"or",constructor:_condition.default.SequentialOr},{starter:!0,name:"xor",constructor:_condition.default.SequentialXor},{starter:!0,name:"nor",constructor:_condition.default.SequentialNor},{starter:!0,name:"nand",constructor:_condition.default.SequentialNand},{starter:!0,name:"xnor",constructor:_condition.default.SequentialXnor},{starter:!0,name:"anda",constructor:_condition.default.ParallelAnd},{starter:!0,name:"ora",constructor:_condition.default.ParallelOr},{starter:!0,name:"xora",constructor:_condition.default.ParallelXor},{starter:!0,name:"nora",constructor:_condition.default.ParallelNor},{starter:!0,name:"nanda",constructor:_condition.default.ParallelNand},{starter:!0,name:"xnora",constructor:_condition.default.ParallelXnor}].map(method=>Object.assign(method,{compile:(root,...params)=>{if(params.length-!root<1)throw new Error(`.${method.name}() needs two or more Condition operands`);params=params.map(fromAny);return root&&params.unshift(root),new method.constructor(...params)}})),...[{name:"not",constructor:_condition.default.NegativeCondition},{name:"bool",constructor:_condition.default.BooleanCondition}].map(method=>Object.assign(method,{compile:(root,...params)=>{if(params.length)throw new Error(`.${method.name}() doesn't need any parameter`);return new method.constructor(root)}})),...[{name:"in",constructor:_condition.default.DelayedCondition},{name:"out",constructor:_condition.default.TimeoutCondition},{name:"during",constructor:_condition.default.DurableCondition},{name:"atmost",constructor:_condition.default.CycleCondition}].map(method=>Object.assign(method,{compile:(root,...params)=>new method.constructor(root,params[0])})),{name:"throw",starter:!0,compile:(root,...params)=>{params=new _condition.default.ErrorCondition(params[0]);return root?new _condition.default.SequentialLink(root,params):params}},...[{name:"onTrue",constructor:_condition.default.TrueEventCondition,defaultHandler:console.log},{name:"onFalse",constructor:_condition.default.FalseEventCondition,defaultHandler:console.warn},{name:"onError",constructor:_condition.default.ErrorEventCondition,defaultHandler:console.error}].map(method=>Object.assign(method,{compile:(root,...params)=>new method.constructor(root,"function"==typeof params[0]?params[0]:method.defaultHandler.bind(null,...params))}))];require.forEach(method=>{let{name,compile,starter}=method;CHAINABLE_PROTOTYPE[name]=function(...params){var clone=new Chainable(this),chain=_.get(clone).chain,root=chain.length&&chain[chain.length-1].condition;if(root||starter)return root=compile(root,...params),chain.push({method:method,params:params,condition:root}),clone;throw new Error(`.${name}() cannot be a first condition`)}});let fromAny=any=>any instanceof _condition.default.Condition?any:_isChainable(any)?any.condition:new(any instanceof Promise?_condition.default.PromiseCondition:"function"==typeof any?_condition.default.FunctionalCondition:_condition.default.StaticCondition)(any);var conditionFrom={fromValue:value=>new _condition.default.StaticCondition(value),fromFunction:fn=>new _condition.default.FunctionalCondition(fn),fromPromise:promise=>new _condition.default.PromiseCondition(promise),fromAny:fromAny};let C={};require.filter(method=>method.starter).forEach(method=>C[method.name]=(...params)=>(new Chainable)[method.name](...params));exports.default={Chainable:Chainable,C:C,conditionFrom:conditionFrom};module.exports=exports.default},{"./assign":1,"./condition":3,"./evaluation":5}],3:[function(require,module,exports){!function(process){!function(){Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _evaluation=_interopRequireDefault(require("./evaluation")),_scope=_interopRequireDefault(require("./scope"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}let _=new WeakMap,now="object"==typeof process&&"function"==typeof process.hrtime?(a,b)=>([a,b]=process.hrtime(),1e3*a+1e-6*b):"object"==typeof performance&&"function"==typeof performance.now?performance.now.bind(performance):Date.now;class Condition{constructor(members={}){_.set(this,Object.assign({},members))}test(){return _evaluation.default.reject(new Error(this.constructor.name+".test() must be implemented on a derived class"))}toPromise(initialValue){return new Promise((resolve,reject)=>this.test(initialValue).on(resolve,reject))}}class StaticCondition extends Condition{constructor(value){super({value:value})}get value(){return _.get(this).value}test(){return _evaluation.default.resolve(_.get(this).value)}toString(){var value=_.get(this).value;return"string"==typeof value?`("${value}")`:`(${String(value)})`}}class TrueCondition extends StaticCondition{constructor(){if(_.has(TrueCondition))return _.get(TrueCondition);super(!0),_.set(TrueCondition,this)}}class FalseCondition extends StaticCondition{constructor(){if(_.has(FalseCondition))return _.get(FalseCondition);super(!1),_.set(FalseCondition,this)}}var TRUE=new TrueCondition;let FALSE=new FalseCondition;class ErrorCondition extends Condition{constructor(reason){super({reason:reason})}get reason(){return _.get(this).reason}test(){return _evaluation.default.reject(_.get(this).reason)}toString(){return"(throw "+String(_.get(this).reason)+")"}}class EternalCondition extends Condition{test(){return new _evaluation.default(()=>{})}toString(){return"(âˆž)"}}class FunctionalCondition extends Condition{constructor(fn){if(super({fn:fn}),"function"!=typeof fn)throw new Error(this.constructor.name+" must be constructed from a function")}get fn(){return _.get(this).fn}test(initialValue,initialScope){let fn=_.get(this).fn,scope=new _scope.default(initialScope);return new _evaluation.default((resolve,reject)=>{try{var result=fn.call(null,initialValue,scope.getChildContext());"function"==typeof result&&result.condition instanceof Condition?result.condition.test(initialValue).on(resolve,reject):result instanceof Condition?result.test(initialValue,scope).on(resolve,reject):result instanceof Promise?new PromiseCondition(result).test(initialValue,scope).on(resolve,reject):resolve(result)}catch(e){reject(e)}})}toString(){var fn=_.get(this).fn;return"Æ’("+String(fn)+")"}}class PromiseCondition extends Condition{constructor(promise){if(super({promise:promise}),!(promise instanceof Promise))throw new Error(this.constructor.name+" must be constructed from a Promise")}get promise(){return _.get(this).promise}test(){return new _evaluation.default((resolve,reject)=>_.get(this).promise.then(resolve,reject))}toString(){return"("+String(_.get(this).promise)+")"}}class ConditionList extends Condition{constructor(...conditions){if(super({conditions:conditions}),conditions.some(condition=>!(condition instanceof Condition)))throw new Error(this.constructor.name+" must be constructed from Condition objects only");if(conditions.length<2)throw new Error(this.constructor.name+" must be constructed from at least two Condition objects")}get conditions(){return _.get(this).conditions.slice()}get length(){return _.get(this).conditions.length}toString(){return"["+_.get(this).conditions.map(String).join()+"]"}}var Sequential=operator=>class extends ConditionList{test(initialValue,initialScope){let scope=new _scope.default(initialScope),conditions=_.get(this).conditions,aborted,subEvaluation;return new _evaluation.default((resolve,reject)=>{let result,testOne=(index=0)=>{aborted||(index>=conditions.length?resolve(result):(subEvaluation=conditions[index].test(index?result:initialValue,scope)).on(value=>{value={value:value,isFirst:!index,isLast:index+1>=conditions.length,result:result,shouldBreak:!1};try{operator.call(null,value),result=value.result}catch(reason){return void reject(reason)}testOne(value.shouldBreak?1/0:++index)},reject))};testOne(0)},()=>{aborted=!0,subEvaluation&&subEvaluation.abort()})}toString(){return"["+_.get(this).conditions.map(String).join(operator.name)+"]"}},Parallel=operator=>class extends ConditionList{test(initialValue,initialScope){let conditions=_.get(this).conditions,length=conditions.length,scope=new _scope.default(initialScope),aborted,subEvaluations;return new _evaluation.default((resolve,reject)=>{let result,done,executed=0,shouldReject=reason=>{done||aborted||(reject(reason),done=!0)},onResolvedOne=value=>{var isFirst=!executed,isLast=++executed>=length,value={value:value,isFirst:isFirst,isLast:isLast,result:result,shouldBreak:!1};try{operator.call(null,value),result=value.result,!value.shouldBreak&&!isLast||done||aborted||(resolve(result),done=!0)}catch(reason){shouldReject(reason)}};subEvaluations=conditions.map(condition=>{condition=condition.test(initialValue,scope.fork());return condition.ona(onResolvedOne,shouldReject),condition})},()=>{aborted=!0,subEvaluations&&subEvaluations.forEach(subEvaluation=>subEvaluation.abort())})}toString(){return"["+_.get(this).conditions.map(String).join("â‹•"+operator.name+"â‹•")+"]"}},OR=r=>{r.result=r.result||r.value,r.shouldBreak=r.result},AND=r=>{r.result=(r.isFirst||r.result)&&r.value,r.shouldBreak=!r.result},NOR=r=>{r.result=(r.isFirst||r.result)&&!r.value,r.shouldBreak=r.value},NAND=r=>{r.result=r.result||!r.value,r.shouldBreak=r.result},XOR=r=>{r.result=r.isFirst?r.value:!r.result&&r.value||!r.value&&r.result},XNOR=r=>{r.result=r.isFirst?r.value:!r.result&&!r.value||r.result&&r.value},LINK=r=>{r.result=r.value};class SequentialOr extends Sequential(OR){}class SequentialAnd extends Sequential(AND){}class SequentialNor extends Sequential(NOR){}class SequentialNand extends Sequential(NAND){}class SequentialXor extends Sequential(XOR){}class SequentialXnor extends Sequential(XNOR){}class SequentialLink extends Sequential(LINK){}class ParallelOr extends Parallel(OR){}class ParallelAnd extends Parallel(AND){}class ParallelNor extends Parallel(NOR){}class ParallelNand extends Parallel(NAND){}class ParallelXor extends Parallel(XOR){}class ParallelXnor extends Parallel(XNOR){}class ParallelLink extends Parallel(LINK){}class UnaryProxyCondition extends Condition{constructor(source,members={}){if(super(Object.assign({},members,{source:source})),!(source instanceof Condition))throw new Error(this.constructor.name+" must be constructed from a Condition object")}get source(){return _.get(this).source}toString(){return"(Proxy: "+_.get(this).source.toString()+")"}}class DelayedCondition extends UnaryProxyCondition{constructor(source,delay=0){if(super(source),delay=+delay,Number.isNaN(delay))throw new Error(this.constructor.name+"(..., delay) requires a numeric value or it can be omitted");if(1e17<(delay=delay<0?0:delay))return new EternalCondition;_.get(this).delay=delay}test(...params){let{source,delay}=_.get(this),handle,subEvaluation;return new _evaluation.default((resolve,reject)=>handle=setTimeout(()=>{handle=null,(subEvaluation=source.test(...params)).on(resolve,reject)},delay),()=>{handle&&(clearTimeout(handle),handle=null),subEvaluation&&subEvaluation.abort()})}get delay(){return _.get(this).delay}toString(){var{source,delay}=_.get(this);return`{${delay}msâ†—${source.toString()}}`}}class DurableCondition extends UnaryProxyCondition{constructor(source,duration=0){if(super(source),duration=+duration,Number.isNaN(duration))throw new Error(this.constructor.name+" expects a numeric duration or it can be omitted");return duration<0?FALSE:duration?(1e17<duration&&(duration=1/0),void(_.get(this).duration=duration)):source}get duration(){return _.get(this).duration}test(initialValue,initialScope){let{source,duration}=_.get(this),scope=new _scope.default(initialScope),commit=scope.commit(),t0=now(),aborted,subEvaluation;return new _evaluation.default((resolve,reject)=>{let attempt=()=>{(subEvaluation=source.test(initialValue,scope.checkout(commit))).on(value=>{aborted||(!value||now()-t0>=duration?(resolve(value),scope.deleteCommit(commit)):setTimeout(attempt,0))},reject)};attempt()},()=>{aborted=!0,subEvaluation&&subEvaluation.abort(),commit.deleteCommit(commit)})}toString(){return _.get(this).source.toString()}}class TimeoutCondition extends UnaryProxyCondition{constructor(source,duration=1/0){if(super(source),duration=+duration,Number.isNaN(duration))throw new Error(this.constructor.name+" expects a numeric duration or it can be omitted");return 1e17<duration?source:duration<=0?FALSE:void(_.get(this).duration=duration)}get duration(){return _.get(this).duration}test(...params){let{source,duration}=_.get(this),done,handle,subEvaluation,clear=()=>{handle&&(clearTimeout(handle),handle=null)};return new _evaluation.default((resolve,reject)=>{let shouldResolve=value=>{done||(done=!0,clear(),resolve(value))};subEvaluation=source.test(...params),handle=setTimeout(()=>{handle=null,shouldResolve(!1),subEvaluation.abort()},duration),subEvaluation.ona(shouldResolve,reason=>{done||(done=!0,clear(),reject(reason))})},()=>{done=!0,clear(),subEvaluation&&subEvaluation.abort()})}toString(){return _.get(this).source.toString()}}class CycleCondition extends UnaryProxyCondition{constructor(source,attempts=1){if(super(source),attempts=+attempts,Number.isNaN(attempts))throw new Error(this.constructor.name+" requires an integer for attempts or it can be omitted");if(attempts<1)return FALSE;attempts=Math.floor(attempts),_.get(this).attempts=attempts}get attempts(){return _.get(this).attempts}test(initialValue,initialScope){let{source,attempts}=_.get(this),scope=new _scope.default(initialScope),commit=scope.commit(),subEvaluation,aborted,countdown=attempts;return new _evaluation.default((resolve,reject)=>{let attempt=()=>{aborted||(subEvaluation=source.test(initialValue,scope.checkout(commit))).on(value=>{aborted||(value||--countdown<1?(resolve(value),scope.deleteCommit(commit)):setTimeout(attempt,0))},reject)};attempt()},()=>{aborted=!0,subEvaluation&&subEvaluation.abort(),scope.deleteCommit(commit)})}}class NegativeCondition extends UnaryProxyCondition{constructor(source){return super(source),source instanceof NegativeCondition?new BooleanCondition(source.source):source instanceof BooleanCondition?new NegativeCondition(source.source):void 0}test(...params){let source=_.get(this).source,subEvaluation;return new _evaluation.default((resolve,reject)=>{(subEvaluation=source.test(...params)).on(result=>resolve(!result),reject)},()=>subEvaluation&&subEvaluation.abort())}toString(){return"!"+_.get(this).source.toString()}}class BooleanCondition extends UnaryProxyCondition{constructor(source){if(super(source),source instanceof BooleanCondition||source instanceof NegativeCondition)return source}test(...params){let source=_.get(this).source,subEvaluation;return new _evaluation.default((resolve,reject)=>{(subEvaluation=source.test(...params)).on(result=>resolve(!!result),reject)},()=>subEvaluation&&subEvaluation.abort())}toString(){return"Boolean"+_.get(this).source.toString()}}class EventCondition extends UnaryProxyCondition{constructor(source,onResolve,onReject){super(source),_.get(this).onResolve="function"==typeof onResolve?onResolve:_=>{},_.get(this).onReject="function"==typeof onReject?onReject:_=>{}}test(...params){let{source,onResolve,onReject}=_.get(this),subEvaluation;return new _evaluation.default((resolve,reject)=>{(subEvaluation=source.test(...params)).on(value=>{onResolve.call(null,value),resolve(value)},reason=>{onReject.call(null,reason),reject(reason)})},()=>{subEvaluation&&subEvaluation.abort()})}toString(){return _.get(this).source.toString()}}class TrueEventCondition extends EventCondition{constructor(source,handler){if(super(source,value=>value&&handler.call(null,value)),"function"!=typeof handler)throw new Error(this.constructor.name+" needs a function as handler")}}class FalseEventCondition extends EventCondition{constructor(source,handler){if(super(source,value=>value||handler.call(null,value)),"function"!=typeof handler)throw new Error(this.constructor.name+" needs a function as handler")}}class ErrorEventCondition extends EventCondition{constructor(source,handler){if(super(source,void 0,handler),"function"!=typeof handler)throw new Error(this.constructor.name+" needs a function as handler")}}exports.default={Condition:Condition,StaticCondition:StaticCondition,TrueCondition:TrueCondition,FalseCondition:FalseCondition,FunctionalCondition:FunctionalCondition,PromiseCondition:PromiseCondition,ErrorCondition:ErrorCondition,EternalCondition:EternalCondition,SequentialAnd:SequentialAnd,SequentialOr:SequentialOr,SequentialXor:SequentialXor,SequentialNor:SequentialNor,SequentialNand:SequentialNand,SequentialXnor:SequentialXnor,SequentialLink:SequentialLink,ParallelAnd:ParallelAnd,ParallelOr:ParallelOr,ParallelXor:ParallelXor,ParallelNor:ParallelNor,ParallelNand:ParallelNand,ParallelXnor:ParallelXnor,ParallelLink:ParallelLink,NegativeCondition:NegativeCondition,BooleanCondition:BooleanCondition,DelayedCondition:DelayedCondition,CycleCondition:CycleCondition,DurableCondition:DurableCondition,TimeoutCondition:TimeoutCondition,EventCondition:EventCondition,TrueEventCondition:TrueEventCondition,FalseEventCondition:FalseEventCondition,ErrorEventCondition:ErrorEventCondition,TRUE:TRUE,FALSE:FALSE};module.exports=exports.default}.call(this)}.call(this,require("_process"))},{"./evaluation":5,"./scope":6,_process:7}],4:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _evaluation=_interopRequireDefault(require("./evaluation")),_chainable=require("./chainable"),_condition=_interopRequireDefault(require("./condition"));function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}(0,_interopRequireDefault(require("./assign")).default)(_chainable.C,{Evaluation:_evaluation.default,Chainable:_chainable.Chainable,condition:(_condition.default,_chainable.conditionFrom)});exports.default=_chainable.C;module.exports=exports.default},{"./assign":1,"./chainable":2,"./condition":3,"./evaluation":5}],5:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;let _=new WeakMap;class DisposableMegaphone{constructor(){_.set(this,{callbacks:[]})}speak(...params){var self=_.get(this);if(self.used)throw new Error(this.constructor.name+".speak() must be called only once. Cannot accept "+String(params)+" after "+String(self.params));self.used=!0,self.params=params,self.callbacks.forEach(callback=>callback.apply(null,params)),self.callbacks=null}listen(callback){if("function"!=typeof callback)throw new Error(this.constructor.name+".listen requires a function as callback");var{used,params,callbacks}=_.get(this);used?callback.apply(null,params):callbacks.push(callback)}}function EVALUATION_REJECT(reason){var self=_.get(this);self.done?console.warn("Resolver function attempted to call onRejected after status was already set, ignored"):(self.done=!0,self.reason=reason,self.status="rejected",self.queue.speak((resolve,reject)=>reject(reason)))}class Evaluation{static resolve(value){return new Evaluation(resolve=>resolve(value))}static reject(reason){return new Evaluation((_,reject)=>reject(reason))}constructor(resolver,aborter=()=>{}){if("function"!=typeof resolver)throw new Error(this.constructor.name+" resolver "+String(resolver)+" is not a function");if("function"!=typeof aborter)throw new Error(this.constructor.name+" aborter "+String(aborter)+" is not a function");_.set(this,{resolver:resolver,aborter:aborter,done:!1,status:"pending",queue:new DisposableMegaphone})}abort(reason="aborted"){var{status,aborter}=_.get(this);if("ongoing"!==status)return"pending"===status&&(EVALUATION_REJECT.call(this,reason),!0);EVALUATION_REJECT.call(this,reason);try{aborter.call(null)}catch(e){console.warn(this.constructor.name+".abort()",e)}return!0}on(onFulfilled,onRejected){"function"!=typeof onFulfilled&&(onFulfilled=x=>x),"function"!=typeof onRejected&&(onRejected=e=>{throw e});var self=_.get(this);if("pending"===self.status){self.status="ongoing";try{self.resolver.call(null,function(value){var self=_.get(this);self.done?console.warn("Resolver function attempted to call onFulfilled after status was already set, ignored"):(self.done=!0,self.value=value,self.status="resolved",self.queue.speak((resolve,reject)=>resolve(value)))}.bind(this),EVALUATION_REJECT.bind(this))}catch(reason){EVALUATION_REJECT.call(this,reason)}finally{self.async=!self.done}}"resolved"===self.status?onFulfilled.call(null,self.value):"rejected"===self.status?onRejected.call(null,self.reason):"ongoing"===self.status&&self.queue.listen(fn=>fn(onFulfilled,onRejected))}ona(onFulfilled,onRejected){Promise.resolve().then(_=>{this.on(onFulfilled,onRejected)})}get status(){return _.get(this).status}get async(){var{status,async}=_.get(this);if("pending"===status)throw new Error(".async does not exist for ["+status+"] status");return!!async}get value(){var{status,value}=_.get(this);if("resolved"!==status)throw new Error(".value does not exist for ["+status+"] status");return value}get reason(){var{status,reason}=_.get(this);if("rejected"!==status)throw new Error(".reason does not exist for ["+status+"] status");return reason}toString(){var{status,reason,value}=_.get(this);return`<${status}>`+("resolved"===status?value:"rejected"===status?reason:"")}toPromise(){return new Promise(this.on.bind(this))}then(onFulfilled,onRejected){return this.toPromise().then(onFulfilled,onRejected)}get[Symbol.toStringTag](){return this.toString()}}exports.default=Evaluation;module.exports=exports.default},{}],6:[function(require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;let _=new WeakMap;exports.default=class Scope{constructor(source){if(source instanceof Scope)return source;source=Object.assign({},source),_.set(this,{context:source,commits:new Map})}getChildContext(){var self=_.get(this),childContext=Object.assign({},self.context);return self.context=childContext}fork(){return new Scope(_.get(this).context)}commit(description){var{context,commits}=_.get(this),description=Symbol(description);return commits.set(description,Object.assign({},context)),description}checkout(symbol){var self=_.get(this),commits=self.commits;if(commits.has(symbol))return self.context=Object.assign({},commits.get(symbol)),this;throw new Error(this.constructor.name+".checkout() can't find this commit")}deleteCommit(symbol){return _.get(this).commits.delete(symbol)}};module.exports=exports.default},{}],7:[function(require,module,exports){var cachedSetTimeout,cachedClearTimeout,module=module.exports={};function defaultSetTimout(){throw new Error("setTimeout has not been defined")}function defaultClearTimeout(){throw new Error("clearTimeout has not been defined")}try{cachedSetTimeout="function"==typeof setTimeout?setTimeout:defaultSetTimout}catch(e){cachedSetTimeout=defaultSetTimout}try{cachedClearTimeout="function"==typeof clearTimeout?clearTimeout:defaultClearTimeout}catch(e){cachedClearTimeout=defaultClearTimeout}function runTimeout(fun){if(cachedSetTimeout===setTimeout)return setTimeout(fun,0);if((cachedSetTimeout===defaultSetTimout||!cachedSetTimeout)&&setTimeout)return(cachedSetTimeout=setTimeout)(fun,0);try{return cachedSetTimeout(fun,0)}catch(e){try{return cachedSetTimeout.call(null,fun,0)}catch(e){return cachedSetTimeout.call(this,fun,0)}}}var currentQueue,queue=[],draining=!1,queueIndex=-1;function cleanUpNextTick(){draining&&currentQueue&&(draining=!1,currentQueue.length?queue=currentQueue.concat(queue):queueIndex=-1,queue.length)&&drainQueue()}function drainQueue(){if(!draining){for(var timeout=runTimeout(cleanUpNextTick),len=(draining=!0,queue.length);len;){for(currentQueue=queue,queue=[];++queueIndex<len;)currentQueue&&currentQueue[queueIndex].run();queueIndex=-1,len=queue.length}currentQueue=null,draining=!1,!function(marker){if(cachedClearTimeout===clearTimeout)return clearTimeout(marker);if((cachedClearTimeout===defaultClearTimeout||!cachedClearTimeout)&&clearTimeout)return(cachedClearTimeout=clearTimeout)(marker);try{cachedClearTimeout(marker)}catch(e){try{return cachedClearTimeout.call(null,marker)}catch(e){return cachedClearTimeout.call(this,marker)}}}(timeout)}}function Item(fun,array){this.fun=fun,this.array=array}function noop(){}module.nextTick=function(fun){var args=new Array(arguments.length-1);if(1<arguments.length)for(var i=1;i<arguments.length;i++)args[i-1]=arguments[i];queue.push(new Item(fun,args)),1!==queue.length||draining||runTimeout(drainQueue)},Item.prototype.run=function(){this.fun.apply(null,this.array)},module.title="browser",module.browser=!0,module.env={},module.argv=[],module.version="",module.versions={},module.on=noop,module.addListener=noop,module.once=noop,module.off=noop,module.removeListener=noop,module.removeAllListeners=noop,module.emit=noop,module.prependListener=noop,module.prependOnceListener=noop,module.listeners=function(name){return[]},module.binding=function(name){throw new Error("process.binding is not supported")},module.cwd=function(){return"/"},module.chdir=function(dir){throw new Error("process.chdir is not supported")},module.umask=function(){return 0}},{}]},{},[4])(4)});